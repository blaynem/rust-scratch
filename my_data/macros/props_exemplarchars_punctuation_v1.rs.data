// @generated
# [doc = " Implement `DataProvider<ExemplarCharactersPunctuationV1Marker>` on the given struct using the data"] # [doc = r" hardcoded in this file. This allows the struct to be used with"] # [doc = r" `icu`'s `_unstable` constructors."] # [doc (hidden)] # [macro_export] macro_rules ! __impl_props_exemplarchars_punctuation_v1 { ($ provider : ty) => { # [clippy :: msrv = "1.67"] const _ : () = < $ provider > :: MUST_USE_MAKE_PROVIDER_MACRO ; # [clippy :: msrv = "1.67"] impl icu_provider :: DataProvider < icu::properties :: provider :: ExemplarCharactersPunctuationV1Marker > for $ provider { fn load (& self , req : icu_provider :: DataRequest ,) -> Result < icu_provider :: DataResponse < icu::properties :: provider :: ExemplarCharactersPunctuationV1Marker > , icu_provider :: DataError > { static JA : < icu::properties :: provider :: ExemplarCharactersPunctuationV1Marker as icu_provider :: DataMarker > :: Yokeable = icu::properties :: provider :: PropertyUnicodeSetV1 :: CPInversionListStrList (icu::collections :: codepointinvliststringlist :: CodePointInversionListAndStringList :: from_parts_unchecked (unsafe { # [allow (unused_unsafe)] icu::collections :: codepointinvlist :: CodePointInversionList :: from_parts_unchecked (unsafe { zerovec :: ZeroVec :: from_bytes_unchecked (b"!\0\0\0$\0\0\0%\0\0\0'\0\0\0(\0\0\0+\0\0\0,\0\0\x000\0\0\0:\0\0\0<\0\0\0?\0\0\0A\0\0\0[\0\0\0^\0\0\0_\0\0\0`\0\0\0\xA7\0\0\0\xA8\0\0\0\xB6\0\0\0\xB7\0\0\0\x10 \0\0\x12 \0\0\x14 \0\0\x17 \0\0\x18 \0\0\x1A \0\0\x1C \0\0\x1E \0\0  \0\0\" \0\0% \0\0' \0\x000 \0\x001 \0\x002 \0\x004 \0\0; \0\0< \0\0> \0\0? \0\0\x010\0\0\x040\0\0\x080\0\0\x120\0\0\x140\0\0\x160\0\0\x1C0\0\0\x1D0\0\0\xFB0\0\0\xFC0\0\0\x01\xFF\0\0\x04\xFF\0\0\x05\xFF\0\0\x0B\xFF\0\0\x0C\xFF\0\0\x10\xFF\0\0\x1A\xFF\0\0\x1C\xFF\0\0\x1F\xFF\0\0!\xFF\0\0;\xFF\0\0>\xFF\0\0?\xFF\0\0@\xFF\0\0[\xFF\0\0\\\xFF\0\0]\xFF\0\0^\xFF\0\0a\xFF\0\0f\xFF\0\0") } , 85u32) } , zerovec :: VarZeroVec :: new ()) ,) ; static UND : < icu::properties :: provider :: ExemplarCharactersPunctuationV1Marker as icu_provider :: DataMarker > :: Yokeable = icu::properties :: provider :: PropertyUnicodeSetV1 :: CPInversionListStrList (icu::collections :: codepointinvliststringlist :: CodePointInversionListAndStringList :: from_parts_unchecked (unsafe { # [allow (unused_unsafe)] icu::collections :: codepointinvlist :: CodePointInversionList :: from_parts_unchecked (unsafe { zerovec :: ZeroVec :: from_bytes_unchecked (b"!\0\0\0\"\0\0\0(\0\0\0*\0\0\0,\0\0\0/\0\0\0:\0\0\0<\0\0\0?\0\0\0@\0\0\0[\0\0\0^\0\0\0\x11 \0\0\x12 \0\0") } , 13u32) } , zerovec :: VarZeroVec :: new ()) ,) ; static VALUES : [& < icu::properties :: provider :: ExemplarCharactersPunctuationV1Marker as icu_provider :: DataMarker > :: Yokeable ; 2usize] = [& JA , & UND] ; static KEYS : [& str ; 2usize] = ["ja" , "und"] ; if let Ok (payload) = KEYS . binary_search_by (| k | req . locale . strict_cmp (k . as_bytes ()) . reverse ()) . map (| i | * unsafe { VALUES . get_unchecked (i) }) { Ok (icu_provider :: DataResponse { payload : Some (icu_provider :: DataPayload :: from_static_ref (payload)) , metadata : Default :: default () , }) } else { Err (icu_provider :: DataErrorKind :: MissingLocale . with_req (< icu::properties :: provider :: ExemplarCharactersPunctuationV1Marker as icu_provider :: KeyedDataMarker > :: KEY , req)) } } } } }